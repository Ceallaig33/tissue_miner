---
title: "TissueMiner: a R-tutorial to visualize cell dynamics in 2D tissues"
author: "Raphael Etournay"
date: "15 September 2015"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
---



# Quick introduction to TissueMiner and the R-language

* This tutorial assumes that 
    + TissueMiner has been installed [see installation procedure](https://github.com/mpicbg-scicomp/tissue_miner) 
    + timelapses have been processed using the TissueMiner workflow [here](https://github.com/mpicbg-scicomp/tissue_miner).

* **We provide three processed time-lapses** corresponding to 3 wild-type *Drosophila* pupal wings. [Please, download them here](files.mpi-cbg.de). 

* **No programming skill required:** this tutorial will guide the user, without any previous knowledge in programming, through the main aspects of data manipulation and visualization using the R language. 

* **The power of an existing grammar** to manipulate and to visualize data. The open-source R language now provides very efficient and simple ways to handle important amount of tabular data, using a so called "grammar" of data manipulation (*dplyr* package) and visualization (*ggplot2* package) (ref Wickham). We found R to be ideal for querying our relational databases (*RSQLite* package), and to perform subsequent calculations and analyses for understanding tissue morphogenesis. Thus, the user keeps control of his data by learning a few verbs and the simple syntaxe of the grammar. This gives the advantage of full autonomy on the data that can manipulated without restriction. 

* **TissueMiner extends this grammar** to facilitate the visualization and quantification of cell dynamics during tissue morphogenesis

* **TissueMiner is compatible with the Python programming language**. We provide a Python-tutorial of TissueMiner [here](link)

* **High performance computing plateform**. TissueMiner has been designed to be used in command-line in order to easily batch repetitive tasks and to run tasks on a high performance computing plateform (cluster). 

* **A comprehensive HOWTO**. This tutorial progressively introduces the techniques of data manipulation and visualization for the user to learn how to master them. It is also organized as an *HOWTO* to visualize and quantify cell dynamics in 2D tissues, by a simple copy-paste of the code encapsulated in shaded grey boxes into a R-shell such as in [RStudio](https://www.rstudio.com/products/rstudio/). We strongly encourage the user to use RStudio or a similar software to conveniently run the R programs provide in TissueMiner.

* **TissueMiner can easily be extended** by the user to address project-specific questions

* **Tutorial layout**: the code is encapsulated in shaded grey boxes that delimit **code chunks**. The **resuts** are displayed immediately below in an open box in which all lines start with the ## sign. Within code chunks, **comments** are visible in green and are prefixed with at least a # sign. The comments indicate what the following code does. Here is an example:

```{r layout example, warning=FALSE, message=FALSE, echo=T}
# This is a comment: the code below will print "Welcome to TissueMiner"
print("Welcome to TissueMiner")
```


## Set up TissueMiner locally

### Local TissueMiner installation
```{bash .bash_profile, warning=FALSE, message=FALSE, echo=T, eval=F}
#### Open a terminal and execute the lines below ####

## Set a path to install TissueMiner in you home folder (please use an absolute path)
echo "export TM_HOME=~/tissue_miner" >> .bash_profile
source .bash_profile

## If Git ins't installed yet, please install it
# On Ubuntu run:
sudo apt-get install git

# On MacOs, please download git here
http://git-scm.com/download/mac

## download TissueMiner (require git to be installed)
git clone https://github.com/mpicbg-scicomp/tissue_miner.git ${TM_HOME}

```

### Rstudio installation
Please, follow the instructions [here](https://www.rstudio.com/products/rstudio/) to install RStudio desktop.

### Avconv installation
```{bash avconv, warning=FALSE, message=FALSE, echo=T, eval=F}
## install avconv (only needed for movie rendering)
# On Ubuntu
sudo apt-get install --assume-yes libav-tools
# On Mac, please visit
http://superuser.com/questions/568464/how-to-install-libav-avconv-on-osx
```

## Set up the Rstudio environement
* **Please modify the paths according to your data location**
* **Always execute the code below before running the analysis**
```{r Setup IN/OUT, warning=FALSE, message=FALSE, echo=T,results='hide'}
# Define path to all processed movies: TO BE EDITED BY THE USER
movieDbBaseDir="/media/project_raphael@fileserver/movieSegmentation"

# Define a working directory where to save the analysis: TO BE EDITED BY THE USER
outDataBaseDir="/home/etournay/Documents"
```

```{r Setup environment, warning=FALSE, message=FALSE, echo=T,results='hide'}
# Set up path to the TissueMiner code
# This command requires that the global environment TM_HOME is defined in the .bash_profile
scriptsDir=Sys.getenv("TM_HOME")

# Load TissueMiner libraries
source(file.path(scriptsDir, "commons/TMCommons.R"))
source(file.path(scriptsDir, "db/movie_rotation/RotationFunctions.R"))
source(file.path(scriptsDir, "commons/BaseQueryFunctions.R"))
source(file.path(scriptsDir, "config/flywing_tm_config.R"))

# Load a R library
library("zoo")

# Set up working directory
mcdir(outDataBaseDir)

## Set general theme for graphs: more specific tuning must be done for each graph
theme_set(theme_bw())
theme_update(panel.grid.major=element_line(linetype= "dotted", color="black", size=0.2),
             panel.border = element_rect(size=0.3,color="black",fill=NA),
             axis.ticks=element_line(size=0.2),
             axis.ticks.length=unit(0.1,"cm"),
             legend.key = element_blank()
)

# Hardwire isotropic deformation color scheme
isotropColors <- c("division"="orange",
                   "extrusion"="turquoise",
                   "cell_area"="green",
                   "sumContrib"="blue",
                   "tissue_area"="darkred")

## hardwire the movie color scheme
movieColors <- c("WT_25deg_111102"="blue",
          "WT_25deg_111103"="darkgreen",
          "WT_25deg_120531"="red"
)

```



## R: the basics

Many books or web sites describe the R language, and we only introduce the necessary knowledge to understand this tutorial.
We recommend of few references that have been useful to us:

* The art of R programming
* The R cookbook
* The R graphics cookbook
* And some websites...

### Variable assignment and simple instructions

```{r The basics 1, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# assign a number to the variables x and y
x <- 2
y <- 3
# display the result of x + y
x + y

# is x equal y?
x==y

# is x different from y?
x!=y

# is x superior to y? 
x>y

# is x inferior to y?
x<y
```

***

### A vector is a series of values. 
```{r The basics 2, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# assign a vector to x and to y:
x <- c(4,3,8)
y <- c(6,7,2)
# assign a bolean vector to z:
z <- c(TRUE,FALSE,TRUE)
# display the result of x + y (element-wise addition):
x + y
# display the result of x + y + z (z is automatically coerced to integers)
x + y + z
```

***
### Named vectors
In some cases, it is covenient to name each element of the vector. Such a vector is usefull to store configuration parameters.
```{r The basics 3, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# assign a named vector to x:
x <- c("movie1"="red", "movie2"="blue", "movie3"="green")
# display the content of x
x
```

***

### Tabular data: dataframe
Tabular data that we obtain from the relational database are stored in a table refered to as *dataframe* in the R language. This tutorial essentially shows how to manipulate dataframes in order to perform calculations and prepare the data for plotting. A dataframe is composed of columns that correspond to vectors of identical length.
```{r The basics 4, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Assign a data frame to x:
x <- data.frame(frame=c(1,2,3), cell_area=c(20,22,24))
# display the content of x:
x
# display the number of lines in x:
nrow(x)
# display the 2 first rows of x:
head(x, n=2)
# display the 2 last rows of x:
tail(x, n=2)
```


## How to query a relational database ?

### Open a connection to the database

* Database format: SQLite
* Open a connection to one database: **openMovieDb()** function using the RSQLite package
* The name of the time-lapse is used to identify the corresponding database
* The SQLite connection is assign to a "db" variable.


```{r SQLite DB connection, warning=FALSE, message=FALSE, echo=TRUE, cache=FALSE}
# Define path to all time-lapses
movieDbBaseDir <- "/media/project_raphael@fileserver/movieSegmentation"
# Define path a particular time-lapse called "WT_25deg_111102"
movieDir <- file.path(movieDbBaseDir, c("WT_25deg_111102"))
# Connection to the DB stored in the "db" variable
db <- openMovieDb(movieDir)
```

***

### Query the database using the SQL language

* **Simplycity of the SQL language:** only three words ***select***, ***from***, and ***where*** are sufficient to perform database queries: one can ***select*** the desired columns ***from*** a given table ***where*** the rows of a given column fulfill a user defined criterium.
* More complicated SQL queries are possible, but we will instead use the grammar of data manipulation provided in R to manipulate the dataframes in the computer memory.

```{r Simple SQL query, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Use the built-in "dbGetQuery" function to query the database "db" using a SQL statement in quotes
# Assign the resulting data frame to the "cellProperties" variable
cellProperties <- dbGetQuery(db, "select cell_id, frame, area from cells")
# show first lines of the table
head(cellProperties)

# Filter out the margin cell (id 10000) around the tissue
cellProperties <- dbGetQuery(db, "select cell_id, frame, area from cells where cell_id!=10000") 

```

```{r Simple SQL query: select all columns, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Select all columns of a table
allCellProperties <- dbGetQuery(db, "select * from cells where cell_id!=10000") 
```

## Manipulate large data sets using a grammar of data manipulation

* Here, we briefly introduce the main verbs and the syntax of the grammar of data manipulation supplied by the dplyr package. In practice, just **a single operator and about 5 verbs only are sufficient to effectively manipulate data**. We also encourage the user to download the Rstudio cheat sheet [here](http://www.rstudio.com/resources/cheatsheets/) in which the grammar is summarized.

* Simply stated, this grammar allows the user to **chain a series of operations** by using the pipe operator **%>%**. In each step of the chain, every intermediate result is taken as an input for the next operation. Each type of operation on dataframes is identified by a verb. In the present tutorial, we mainly use the following few verbs:

    + **dbGetQuery**: send a SQL query to a database and retuns a table
    + **mutate**: perform calculations on columns, by adding or modifying existing ones
    + **summarize**: compute summary statistics
    + **group_by** (and **ungroup**): helpful to mutate or summarize data on user-defined data subsets
    + **filter**: parse data on row content
    + **select**: parse data on column names
    + **arrange**: order values of desired columns
    + **inner_join**: merge two data frames by intersecting user-defined columns
    + **melt** or **gather**: gather columns into rows
    + **dcast** or **spread**: spread rows into columns

***
* This grammar can be easily extended by the user and can be used in combination with important TissueMiner functions for visualizing and quantifying cell dynamics in 2D-living tissues:

    + **print_head**: display the first lines of the current table and the total number of rows in the table, without affecting the data content
    + **dt.merge**: custom TissueMiner function for fast merging of two dataframes with the possiblity to suffix colunms having identical names
    + **openMovieDb**: open a connection to a selected database
    + **multi_db_query**: query multiple databases and aggregate data into a dataframe
    + **coarseGrid**: assign grid elements to quantities provided positions (center_x and center_y) are present
    + **smooth_grid**: average quantities in time using a moving window (convolution) applied by grid elements
    + **render_frame**: plot quantities from a dataframe onto one movie image
    + **render_movie**: plot quantities from a dataframe onto every movie image and make a movie


### Example 1 
**Aim:** calculate the average cell area in square microns as function of time in hours from start of time-lapse recording. 

```{r Example of dplyr, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# We query the DB to get cell area and pipe the resulting table the next function
avgCellArea <- dbGetQuery(db, "select cell_id, frame, area from cells") %>%
  # remove the huge artificial margin cell around the tissue
  filter(cell_id!=10000) %>%
  # convert pixel to squared microns knowing that 1px = 0.207 micron
  mutate(area_real=(0.207)^2*area) %>%
  # indicate that the next function must be applied frame-wise 
  group_by(frame) %>%
  # calculate the average area in each frame of the time-lapse
  summarize(area_avg=mean(area_real)) %>%
  # cancel grouping
  ungroup() %>%
  # bring time in seconds into the current table by matching the frame number
  inner_join(dbGetQuery(db, "select * from frames"), by="frame") %>%
  # convert time to hours
  mutate(time_h=round(time_sec/3600, 1)) %>%
  # remove the unecessary columns
  select(-c(frame, time_sec)) %>%
  # order time chronologically
  arrange(time_h)
```

### Example 2
For convenience, we built a custom **print_head()** function to display the first lines of the current table, without affecting the data content. The **print_head()** function can therefore be placed whereever needed in the chain of operations:

```{r Example of print_head, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Here, is an example in which we display the first and last steps
avgCellArea <- dbGetQuery(db, "select cell_id, frame, area from cells") %>% print_head() %>%
  filter(cell_id!=10000) %>% 
  mutate(area_real=(0.207)^2*area) %>% 
  group_by(frame) %>% 
  summarize(area_avg=mean(area_real)) %>% 
  ungroup() %>% 
  inner_join(dbGetQuery(db, "select * from frames"), by="frame") %>%
  mutate(time_h=round(time_sec/3600, 1)) %>% 
  select(-c(frame, time_sec)) %>% 
  arrange(time_h) %>% print_head()
```

## Vectorized conditional statement (ifelse)
The R language provides a vectorized **ifelse()** function that we can then use in combination with the dplyr grammar. The vectorized **ifelse()** function takes 3 arguments corresponding to the condition (if), the consequent (then), and the alternative (else).

```{r Example of ifelse, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Here, is an example in which we display each intermediate step
cell <- dbGetQuery(db, "select cell_id, frame, area, elong_xx, elong_xy from cells") %>% 
  # additional column isMarginCell to flag the margin cell as "true"
  mutate(isMarginCell=ifelse(cell_id==10000, TRUE, FALSE)) %>% print_head()
```


## Modify table layout into wide or long formats

### Wide to long format: the melt() or gather() function.
The  melt() (or gather()) function creates two columns: 

* one 'variable' column listing variable names 
* one 'value' column with their corresponding value.

Both melt() and gather() are equivalent, gather() being the newest implementation from the dplyr package.

```{r Examples of melt or gather, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# Example 1: 
# by default, melt() only gathers numerical data into a pair of {variable, value} columns
longFormat <- melt(cell) %>% print_head()
# by default, gather() gathers all columns
longFormat <- gather(cell) %>% print_head()

# Of note, the two columns {cell_id, frame} uniquely define each cell in frame with its associated properties
# Therefore, to keep consistent data, the frame column should not be gathered

# Example 2: specify which columns to gather into {variable, value} columns
longFormat <- melt(cell, measure.vars = c("area","elong_xx","elong_xy","isMarginCell")) %>% print_head()
# Or
longFormat <- gather(cell, variable, value, c(area,elong_xx,elong_xy,isMarginCell)) %>% print_head()

# Example 3: specify which columns shouldn't be gathered (equivalent to example 2)
longFormat <- melt(cell, id.vars =  c("cell_id","frame")) %>% print_head()
# Or
longFormat <- gather(cell, variable, value, -c(cell_id,frame)) %>% print_head()


```

### Lond to wide format: the dcast() or spread() function
The  dcast() (or spread()) function creates as many columns as variable names contained in the 'variable' column and lists the corresponding values. Both dcast() and spread() are equivalent, spread() being the newest implementation from the tidyr package.

```{r Example of dcast or spread, warning=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
# The melt operation is reversible (the row identifiers must be uniquely defined), but booleans area coerced into numeric format
# Using dcast(), cell_id and frame are the row identifiers, wherease the variable column is spread into column names
example <- cell %>% print_head() %>%
  melt(id.vars =  c("cell_id","frame")) %>% print_head() %>%
  dcast(cell_id+frame~variable, value.var="value") %>% print_head()
# Or
example <- cell %>% print_head() %>%
  gather(variable, value, -c(cell_id,frame)) %>% print_head() %>%
  spread(variable,value) %>% print_head()

```


## Data visualization with ggplot2 

Here, we briefly introduce the main verbs and the syntax of the grammar of data **visualization** supplied by the ggplot2 package. In practice, just a single operator and a few visual marks are sufficient to effectively plot data. We also encourage the user to download the corresponding Rstudio cheat sheet [here](http://www.rstudio.com/resources/cheatsheets/) regarding data visualization with ggplot2.

Simply stated, this grammar allows the user to **chain multiple graphical layers to contruct a graph** by using the plus operator **+**, thereby improving the clarity of the code for complex graphs.


* Some geometrical layers (common types of graphs):
    + **geom_point**: to plot the data as points
    + **geom_line**: to join the points by lines
    + **geom_segment**: to plot a segment such as the representation of a nematic tensor, or a cell bond
    + **geom_polygon**: to plot a polygon such as the representation of a cell


* Some complementary scaling layers:
    + **scale\_x\_continuous** or **scale\_y\_continuous**: to control the x and y axes rendering
    + **scale_color_gradientn**: to use a gradient of colors when rendering the data


* Saving a graph:
    + Formats: raster (jpg, png, tiff, ...) or vector graphics (svg, eps, pdf, ...)
    + **ggsave2()** function: TissueMiner provides the ggsave2() wrapper to the default ggsave() function in order to add more functionality, and we'll use ggsave2() in the rest of this tutorial.

### Example with ggplot:
**Aim:** plot the average cell area in square microns as function of time in hours from start of time-lapse recording:

* use the **ggplot()** function
* ggplot's first argument is the dataframe containing the data to be ploted
* ggplot's **aes()** function: to map the data to the system of coordinates


```{r Example ggplot, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}
# Show the first rows of the previously calculated avgCellArea data frame:
head(avgCellArea)

# Map the data to the system of coordinates using ggplot
ggplot(avgCellArea, aes(x = time_h, y = area_avg)) +
  # plot the average area as a line using geom_line
  geom_line() +
  # add a title
  ggtitle("Average cell area as function of time")

# Save the plot as svg for editing in Inkscape
ggsave2(width=14, unit="in", outputFormat="svg")
```


# Rendering cells, bonds and vertices

* Cells can be rendered as polygons using the vertices ordered anti-clockewisely around each cell. Vertices ordering is performed in the automated TissueMiner workflow.
* The ordered list of vertices around each cell is stored in the *cellshapes.RData* table along with the database file.
* The **geom_polygon()** function is used to represent cells as polygons on the original image.


## Rendering cells and vertices
```{r Rendering cells and vertices: load data, warning=FALSE, message=FALSE, fig.width=11,cache=TRUE}
# Load data into the 'cellshapes' variable
cellshapes <- locload(file.path(movieDir, "cellshapes.RData")) %>% print_head()

# Select a current frame to work with
curFrame <- 70

```

### Example 1: plot cells as polygons in the Cartesian system

```{r Rendering cells and vertices: example1, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}
ggplot(cellshapes %>% filter(frame==curFrame)) +
  # plot cells as polygons:
  geom_polygon(aes(x_pos, y_pos, group=cell_id),color="green",fill="white", size=0.3) +
  # X and Y axes must have the same scale:
  coord_equal() +
  # add a title "frame" followed by a 3-digit padded number:
  ggtitle("Pupal wing cells represented as polygons in Cartesian system")
```

### Example 2: plot cells as polygons in the image coordinate system

```{r Rendering cells and vertices: example2, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}
ggplot(cellshapes %>% filter(frame==curFrame)) +
  geom_polygon(aes(x_pos, y_pos, group=cell_id),color="green",fill="white", size=0.3) + 
  coord_equal() +
  # In an image coordinate system, the Y-axis is pointing downwards. We flip the Y-axis:
  scale_y_continuous(trans = "reverse") +
  # scale_y_continuous(limits=rev(c(0,1900)), trans = "reverse", expand = c(0,0)) +
  ggtitle("Pupal wing cells represented as polygons in image coordinate system")
```

### Example 3: plot cells and vertices

```{r Rendering cells and vertices: example3, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}
ggplot(cellshapes %>% filter(frame==curFrame)) +
  geom_polygon(aes(x_pos, y_pos, group=cell_id),color="green",fill="white", size=0.3) +
  # plot each vertex as a point:
  geom_point(aes(x_pos, y_pos),color="red", size=0.4) + 
  coord_equal() +
  scale_y_continuous(trans = "reverse") +
  ggtitle("Pupal wing cells and vertices")
```

### Example 4: plot cells and vertices on the image

We can now overlay cells and vertices on the wing image. To do so, we built a dedicated **render_frame()** function that loads the specified frame of the time-lapse.
This function takes 'cellshapes' and 'curFrame' as input variables. The **render_frame()** function returns the first layers of the graph that consists of a raster image of the wing and additional specifications such as the Y-axis flipping (scale_y_continuous(trans = "reverse")) and the iso-scaling of the X and Y axes (coord_equal()). 

```{r Rendering cells and vertices: example4, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}
cellshapes %>%
  # add overlay image (! connection to DB required !):
  render_frame(curFrame) +
  geom_polygon(aes(x_pos, y_pos, group=cell_id), color="green",fill=NA, size=0.2) + 
  geom_point(aes(x_pos, y_pos),color="red", size=0.4) +
  ggtitle("Cells and vertices overlaid on the image")

```

### Example 5: Bond Statistics

To analyze bonds and their properties we first need to aggregate the vertex, bond, and directed bond information. This allows for instance to calculate an average bond position from both vertices as shown in the example. Please note that we need to remove duplicates due to the directionality of the bonds in the database.

To encourage and advocate reusable code, we use a small helper function here to aggreate to calcualte mean bond positions.

```{r Bond Statistics, warning=FALSE, message=FALSE, fig.width=11, cache=TRUE}

get_bond_stats <- function(db){
    dbonds <- dbGetQuery(db, "select dbond_id, conj_dbond_id, vertex_id, bond_id from directed_bonds")

    bondStats <- dbonds %>%
        ## use conjugated nature of db to create pairs for connected vertices
        inner_join(., transmute(., conj_dbond_id, vertex_id), by=c("dbond_id"="conj_dbond_id")) %>%
        distinct(bond_id) %>%
        select(-dbond_id, -conj_dbond_id) %>%
        ## reshape into long format to ease downstream vertex data merging and aggregation
        gather(vertex, vertex_id, -bond_id) %>% arrange(bond_id)

    bondStats %<>%
        ## add vertex info and aggregate to mean position
        inner_join(dbGetQuery(db, "select * from vertices")) %>%
        group_by(bond_id) %>%
        summarize(
            bond_mean_x=mean(x_pos),
            bond_mean_y=mean(y_pos)
        ) %>%
        ## add bond information (just length at the moment)
        inner_join(dbGetQuery(db, "select * from bonds"))

    return(bondStats)
}

bondStats <- get_bond_stats(db)

bondStats %>% render_frame(25) + geom_point(aes(bond_mean_x, bond_mean_y, color=bond_length), size=1) +
    scale_color_gradient(name="age", low="green", high="red", limits=c(0, 50))

```

### Further reading: the render_frame() function
Please, read the current definition of the render_frame() function at the [following location](https://github.com/mpicbg-scicomp/tissue_miner/blob/master/commons/MovieFunctions.R)

